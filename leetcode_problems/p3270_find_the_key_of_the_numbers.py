# You are given three positive integers num1, num2, and num3.
# The key of num1, num2, and num3 is defined as a four-digit number such that:
#  - Initially, if any number has less than four digits, it is padded with leading zeros.
#  - The ith digit (1 <= i <= 4) of the key is generated by taking the smallest
#    digit among the ith digits of num1, num2, and num3.
# Return the key of the three numbers without leading zeros (if any).
# --------------------------
# 1 <= num1, num2, num3 <= 9999


def generate_key(num1: int, num2: int, num3: int) -> int:
    # working_sol (73.49%, 82.07%) -> (34ms, 16.50mb)  time: O(max(num1, num2, num3)) | space: O(1)
    key: list[int] = []
    # Take all minimum digits.
    while num1 or num2 or num3:
        dig_1: int = num1 % 10
        dig_2: int = num2 % 10
        dig_3: int = num3 % 10
        key.append(min(dig_1, dig_2, dig_3))
        num1 //= 10
        num2 //= 10
        num3 //= 10
    out: int = 0
    # Reverse them in the correct order.
    for index in range(len(key) - 1, -1, -1):
        out += key[index]
        out *= 10
    out //= 10
    return out


# Time complexity: O(max(num1, num2, num3))
# Always depleting all the 3 input values => O(max(num1, num2, num3)).
# Extra reversing digits, because it's always 4 digits, we can count it as constant.
# --------------------------
# Auxiliary space: O(1).
# `key` <- always of the same size == `4` => O(1).


test_1: int = 1
test_2: int = 10
test_3: int = 1000
test_out: int = 0
assert test_out == generate_key(test_1, test_2, test_3)

test_1 = 987
test_2 = 879
test_3 = 798
test_out = 777
assert test_out == generate_key(test_1, test_2, test_3)

test_1 = 1
test_2 = 2
test_3 = 3
test_out = 1
assert test_out == generate_key(test_1, test_2, test_3)
